var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { useState, useEffect, useRef } from "react";
function useDebounce(data, interval) {
  const [liveData, setLiveData] = useState(data);
  useEffect(() => {
    if (typeof window !== "undefined") {
      const handler = setTimeout(() => {
        setLiveData(data);
      }, interval);
      return () => {
        clearTimeout(handler);
      };
    }
  }, [data, interval]);
  return liveData;
}
function useAutosave({
  data,
  onSave,
  interval = 2e3,
  saveOnUnmount = true
}) {
  const valueOnCleanup = useRef(data);
  const initialRender = useRef(true);
  const debouncedValueToSave = useDebounce(data, interval);
  useEffect(() => {
    if (initialRender.current) {
      initialRender.current = false;
    } else {
      onSave(debouncedValueToSave);
    }
  }, [debouncedValueToSave, onSave]);
  useEffect(() => {
    valueOnCleanup.current = data;
  }, [data]);
  useEffect(() => () => {
    if (saveOnUnmount) {
      onSave(valueOnCleanup.current);
    }
  }, [onSave, saveOnUnmount]);
}
const Autosave = (_a) => {
  var _b = _a, {
    element = null
  } = _b, props = __objRest(_b, [
    "element"
  ]);
  useAutosave(props);
  return element;
};
export { Autosave, useAutosave, useDebounce };
